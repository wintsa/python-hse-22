<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Лекция 10: Классы сложности P и NP</title>

    <link rel="stylesheet" href="../dist/reset.css">
    <link rel="stylesheet" href="../dist/reveal.css">
    <link rel="stylesheet" href="../dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="../plugin/highlight/monokai.css">
    <style>
.reveal .slides section .fragment.step-fade-in-then-out {
	opacity: 0;
	display: none;
	}
.reveal .slides section .fragment.step-fade-in-then-out.current-fragment {
	opacity: 1;
	display: inline;
	}

    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>Лекция 10: Классы сложности P и NP</h3>
            <div>&nbsp;</div>
            <h4>Александр Дерендяев</h4>
        </section>
        <section>
            <section>
                <h1>Классы сложности P и NP</h1>
            </section>
            <section>
                <h4>Временная сложность алгоритма</h4>
                <p><em>Временная сложность алгоритма</em> — число операций алгоритма $А$ в среднем при входе размера
                    $n$:</p>
                \[M_A(n) = \sum_{i\in P} p_i \mu (A_i)\]
                <p>Сложность алгоритма оценивается асимптотической сложностью, т.е. при $n\to\inf$</p>
                <p>Сложность задачи — сложность наилучшего алгоритма, известного для ее решения</p>
            </section>
        </section>
        <section>
            <section>
                <h4>Класс P</h4>
                <p><em>Полиномиальный алгоритм</em> — сложность не превышает полином $p(n)$ для любых данных длинной $n$
                </p>
                <p><em>Задача полиномиально разрешима</em>, если дня нее существует полиномиальный алгоритм</p>
                <p>Класс P — множество всех полиномиально разрешимых задач</p>
            </section>
            <section>
                <h4>Класс P</h4>
                <p>Примеры:</p>
                <ul>
                    <li>Школьный алгоритм сложения: $O(n)$</li>
                    <li>Школьный алгоритм умножения: $O(n^3)$</li>
                    <li>Алгоритм умножения Карацубы: $O(n^{\log_23})$</li>
                    <li>Алгоритм умножения Шёнхаге — Штрассена: $O(n\cdot\log n\cdot\log \log n)$</li>
                </ul>
                <p>Полиномиальный алгоритм — эффективный алгоритм!</p>
            </section>
            <section>
                <p>Зависимость от сложности алогритма</p>
                <table style="font-size: 32px">
                    <thead>
                    <tr>
                        <td rowspan="2">Алгоритм</td>
                        <td rowspan="2">Сложность</td>
                        <td colspan="3">Максимальный размер задачи, решаемой за указанное время</td>
                    </tr>
                    <tr>
                        <td>1 с</td>
                        <td>1 м</td>
                        <td>1 ч</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>А1</td>
                        <td>N</td>
                        <td>1 000</td>
                        <td>60 000</td>
                        <td>3 600 000</td>
                    </tr>
                    <tr>
                        <td>А2</td>
                        <td>$N^2$</td>
                        <td>31</td>
                        <td>244</td>
                        <td>1 897</td>
                    </tr>
                    <tr>
                        <td>А3</td>
                        <td>$N^3$</td>
                        <td>10</td>
                        <td>39</td>
                        <td>153</td>
                    </tr>
                    <tr>
                        <td>А4</td>
                        <td>$2^N$</td>
                        <td>9</td>
                        <td>15</td>
                        <td>21</td>
                    </tr>
                    </tbody>
                </table>
            </section>
            <section>
                <p>Зависимость от скорости компьютера</p>
                <table style="font-size: 32px">
                    <thead>
                    <tr>
                        <td rowspan="2">Алгоритм</td>
                        <td rowspan="2">Сложность</td>
                        <td colspan="2">Максимальный размер задачи</td>
                    </tr>
                    <tr>
                        <td>до ускорения</td>
                        <td>после ускорения в 10 раз</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>А1</td>
                        <td>N</td>
                        <td>S1</td>
                        <td>10*S1</td>
                    </tr>
                    <tr>
                        <td>А2</td>
                        <td>$N^2$</td>
                        <td>S2</td>
                        <td>3.16*S2</td>
                    </tr>
                    <tr>
                        <td>А3</td>
                        <td>$N^3$</td>
                        <td>S3</td>
                        <td>2.15*S3</td>
                    </tr>
                    <tr>
                        <td>А4</td>
                        <td>$2^N$</td>
                        <td>S4</td>
                        <td>S4+3.3</td>
                    </tr>
                    </tbody>
                </table>
            </section>
        </section>
        <section>
            <section>
                <h4>Класс NP</h4>
                <p>Класс NP — класс задач, для которых решение (сертификат) может быть быстро (полиномиально)
                    проверено</p>
                <p>Длина сертификата тоже полиномиальна</p>
                <p>Другая формулировка: NP — класс задач, разрешимых на недетерминированной машине Тьюринга за
                    полиномиальное время</p>
            </section>
            <section>
                <h4>Класс NP</h4>
                <img src="bool.jpg" height="500"/>
            </section>
            <section>
                <h4>Класс NP</h4>
                <img src="gamm.jpg" height="500"/>
            </section>
            <section>
                <h4>Класс NP</h4>
                <p>Еще примеры:</p>
                <ul>
                    <li>Задача выполнимости булевых формул: узнать по данной булевой формуле, существует ли набор
                        входящих в неё переменных, обращающий её в 1. Сертификат — такой набор.
                    </li>
                    <li>Задача о клике: по данному графу узнать, есть ли в нём клики (полные подграфы) заданного
                        размера. Сертификат — номера вершин, образующих клику.
                    </li>
                </ul>
            </section>
            <section>
                <h4>Класс NP</h4>
                <p>Еще примеры:</p>
                <ul>
                    <li>Определение наличия в графе гамильтонова цикла. Сертификат — последовательность вершин,
                        образующих гамильтонов цикл.
                    </li>
                    <li>Неоптимизационный вариант задачи о коммивояжёре (существует ли маршрут не длиннее, чем заданное
                        значение k) — расширенный и более приближенный к реальности вариант предыдущей задачи.
                        Сертификат — такой маршрут.
                    </li>
                </ul>
            </section>
            <section>
                <h4>Класс NP</h4>
                <p>Еще примеры:</p>
                <ul>
                    <li>Существование целочисленного решения у заданной системы линейных неравенств. Сертификат —
                        решение.
                    </li>
                    <li>Отсутствие у заданного числа $m$ делителей $d$ таких что $1 < d \leq k$. Сертификат — разбиение
                        числа $m$ на простые сомножители вместе с их сертификатами простоты.
                    </li>
                </ul>
            </section>
            <section>
                <h4>P = NP ?</h4>
                <p>Если на какой вопрос есть положительный ответ и его можно быстро проверить, то верно ли, что и ответ
                    можно найти так же быстро?</p>
            </section>
            <section>
                <h4>NP-полные и NP-трудные задачи</h4>
                <p>Задача A сводится к задаче B, если метод решения B можно преобразовать в метод решения A</p>
                <p>Задача называется <em>NP-трудной</em>, если любая задача из NP полиномиально сводится к ней</p>
                <p>Задача называется <em>NP-полной</em>, если она NP-трудная и находится в классе NP</p>
            </section>
            <section>
                <h4>NP-полные и NP-трудные задачи</h4>
                <img src="P_np_np-complete_np-hard.svg" style="background-color:white"/>
            </section>
            <section>
                <h4>NP-полные задачи</h4>
                <ul>
                    <li>Задача о выполнимости булевых формул</li>
                    <li>Задача коммивояжёра</li>
                    <li>Задача о вершинном покрытии</li>
                    <li>Задача о покрытии множества</li>
                    <li>Задача о независимом множестве</li>
                    <li>Задача о клике</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h4>Класс EXP</h4>
                <p>Если время решения задачи на машине Тьюринга экспоненциально, то такая задача из класса EXP.</p>
                <p>Тонкость: $O(n^{\log_2n}) = O(2^{\log_2^2n})$ — растет быстрее любого полиномиального, но медленнее
                    $2^n$</p>
            </section>
            <section>
                <h4>Класс EXP</h4>
                <p>Линейное программирование:</p>
                \[z = c_1x_1 + c_2x_2 + \ldots + c_nx_n \to \min(\max) \\
                a_{11}x_1 + a_{12}x_2 + \ldots + a_{1n}x_n \geq b_1 \\
                \cdots \\
                a_{m1}x_1 + a_{m2}x_2 + \ldots + a_{mn}x_n \geq b_m \\
                x_i \geq 0, 1\leq i \leq n
                \]
                <p>Симплекс-метод, который широко используется, хоть и является экспоненциальным</p>
            </section>
            <section>
                <h4>Другие классы сложности</h4>
                <p><a href="https://ru.wikipedia.org/wiki/Класс_сложности" target="_blank">Wiki</a></p>
                <p><a href="https://complexityzoo.net/Petting_Zoo" target="_blank">Зоопарк</a></p>
            </section>
        </section>
        <section>
            <section>
                <h1>Приближенные алгоритмы</h1>
            </section>
            <section>
                <h4>Приближенные алгоритмы</h4>
                <p>Часто, возникшая на практике NP-полная задача настолько важна, что нельзя отказаться от ее
                    решения.</p>
                <p> Если реальные данные позволяют, можно построить <em>неполиномиальный алгоритм</em> для данной
                    задачи.</p>
                <p>В случае, если неполиномиальный алгоритм не работает в приемлемое время, можно попытаться
                    (применительно к задачам оптимизации) найти не точное решение, а некоторое <em>приближенное к
                        нему</em>. </p>
            </section>
            <section>
                <h4>Приближенные алгоритмы</h4>
                <p>Алгоритмы, выдающие приближенные к оптимальному решения, называются <em>приближенными</em>.</p>
                <p> Говорят, что алгоритм решает задачу с ошибкой не более чем в $\rho(n)$ раз, если стоимость
                    найденного им решения ($С$) отличается от стоимости оптимального ($С^*$) не более чем в $\rho(n)$
                    раз:</p>
                $\max(\frac{C}{C^*},\frac{C^*}{C}) \leq \rho(n)$
            </section>
            <section>
                <p>Иногда, для оценки качества алгоритма используют относительную ошибку. Говорят, что алгоритм имеет
                    относительную ошибку не более $\varepsilon(n)$, если:</p>
                \[\frac{C-C^*}{C^*} \leq \varepsilon(n)\]
                <p>Зная $\rho(n)$ легко можно оценить относительную ошибку:</p>
                \[\varepsilon(n) \leq \rho(n)-1\]
            </section>
            <section>
                <p>Для некоторых алгоритмов можно улучшать качество приближения, за счет увеличения времени их
                    работы.</p>
                <p>Схемой приближения для данной оптимизационной задачи называется алгоритм, который, помимо условия
                    задачи получает положительное число $\varepsilon(n)$ и выдает решение с относительной ошибкой не
                    более $\varepsilon(n)$</p>
            </section>
            <section>
                <p>Схема приближения называется полиномиальной, если для некоторого фиксированного $\varepsilon$ время
                    ее работы не превосходит некоторого полинома от размера входа $n$.</p>
                <p>Схема приближения называется полностью полиномиальной, если время ее работы ограничено некоторым
                    полиномом от $n$ и от $1/\varepsilon$, где n-размер входа, а $\varepsilon$ – оценка относительной
                    ошибки.</p>
            </section>
        </section>
        <section>
            <section>
                <h4>Задача о вершинном покрытии</h4>
                <ul style="list-style: none;">
                    <li><em>Вершинное покрытие</em> – такое множество вершин графа, что хотя бы один из концов любого
                        ребра соединен с вершиной входящей в это множество.
                    </li>
                    <li>Размер <em>вершинного покрытия</em> – количество входящих в него вершин.</li>
                    <li>Задача требует нахождения <em>минимально возможного</em> вершинного покрытия графа.</li>
                </ul>
            </section>
            <section>
                <pre><code data-trim data-noescape data-line-numbers class="cpp">
void ApproxVertexCover(G){
    C = {};     // пустое множество
    E = G->E;   // множество ребер графа
    while (E != {}) {
        Edge uv = ExctractRandom(E);
            //Берем произвольное ребро графа
        C->Include(uv->node1);
        C->Include(uv->node2);
            //Вносим вершины, которое соединяет это ребро
            //во множество C
        E->RemoveEdges(uv->node1);
        E->RemoveEdges(uv->node2);
            //Удаляем все ребра инцидентные с вершинами
    }
}
                </code></pre>
            </section>
            <section>
                <img src="vershini.png">
            </section>
            <section>
                <h4>Теорема</h4>
                <p>Алгоритм ApproxVertexCover работает с ошибкой не чем в два раза</p>
                <h4>Доказательство</h4>
                <p>Результатом работы алгоритма действительно является вершинное покрытие, поскольку работа продолжается
                    пока множество непокрытых ребер не останется пустым.</p>
            </section>
            <section>
                <h4>Доказательство</h4>
                <p>Никакие два ребра, рассматриваемые в ходе работы алгоритма, не имеют общей вершины, т.е. количество
                    рассмотренных вершин ровно в два раза больше количества рассмотренных ребер.</p>
                <p> Кроме того, оптимальное покрытие содержит хотя бы одну вершину инцидентную рассматриваемому ребру,
                    т.е. количество вершин в оптимальном решение больше либо равно количеству рассмотренных ребер.</p>
            </section>
        </section>
        <section>
            <section>
                <h1>Задача коммивояжера</h1>
            </section>
            <section>
                <h4>Задача коммивояжера</h4>
                <p>Задача коммивояжера состоит в нахождении во взвешенном графе гамильтонова цикла минимальной стоимости
                    (с минимальной суммой весов ребер).</p>
                <p>На практике функция стоимости ребер обычно удовлетворяет неравенству треугольника, т.е. промежуточная
                    «остановка» в вершине $v$ на пути из $u$ в $w$ не уменьшает его стоимости:</p>
                \[c(u,w) \leq c(u,v)+v(v,w)\]
            </section>
            <section>
                <h4>Задача коммивояжера</h4>
                <img src="comm1.png">
            </section>
            <section>
                <pre><code data-trim data-noescape data-line-numbers class="cpp">
void ApproxTSPTour(G,c){
        //выбираем произвольную вершину
    root = GetRandomVertex(G);
        //строим минимальное покрывающее дерево
    mintree = MSTPrim(G,root);
        //результатом является обход дерева с
        // исключенными повторениями
    path = TreeWalk(mintree);
    DeleteRepetition( path);
}
                </code></pre>
            </section>
            <section>
                <h4>Задача коммивояжера</h4>
                <img src="comm2.png">
            </section>
            <section>
                <h4>Теорема</h4>
                <p>Алгоритм ApproxTSPTour решает задачу коммивояжера с ошибкой не более чем в два раза, если выполнено
                    неравенство треугольника.</p>
            </section>
            <section>
                <h4>Теорема</h4>
                <p>Если $P\neq NP$ и $\rho>1$, то не существует полиномиального приближенного алгоритма, решающего общую
                    задачу коммивояжера с ошибкой не более чем в $\rho$ раз.</p>
            </section>
        </section>
        <section>
            <section>
                <h1>Задача о суммах подмножеств</h1>
            </section>
            <section>
                <h4>Задача о суммах подмножеств</h4>
                <p>Пусть дано некоторое множество $S$, состоящее из целых чисел, и целое число $t$. Требуется выяснить
                    существует ли в $S$ подмножество сумма элементов которого равна $t$.</p>
                <p>Задачу можно поставить как задачу оптимизации, требуя отыскать среди подмножеств сумма которых не
                    превосходит $t$, наиболее близкое к $t$.</p>
            </section>
            <section>
                <p>Для задачи можно построить алгоритм работающий за экспоненциальное время.</p>
                <pre><code data-trim data-noescape data-line-numbers class="python">
def EXPSubSetSum(S,t):
    sums = {0};
    for element in S:
        new_sums = [(s+element) for s in sums if s+element <= t]
            #Удаляем из sums элементы больше t
        sums.update(new_sums)
    return max(sums)
        #возвращаем максимальный элемент из sums
                </code></pre>
            </section>
            <section>
                <h4>Задача о суммах подмножеств</h4>
                <p>Из приведенного алгоритма можно получить полностью полиномиальную схему приближения, если хранить
                    списки не полностью, а в сокращенном варианте.</p>
                <p>Степень сокращения определяется параметром $\delta$: чем он меньше, тем «полнее» список.</p>
            </section>
            <section>
                <h4>Задача о суммах подмножеств</h4>
                <p>Список $L`$ называется $\delta$-сокращением списка $L$, если для любого элемента $y$ из $L$ в списке
                    $L`$ найдется не превосходящий его элемент $z$ для которого выполнено неравенство:</p>
                \[\frac{y-z}{y}\leq\delta\]
            </section>
            <section>
                <p>Для задачи можно построить алгоритм работающий за экспоненциальное время.</p>
                <pre><code data-trim data-noescape data-line-numbers class="python">
def ListTrim(S,delta):
    L = sorted(S)
    last = L[0]
    Ls = [L[0]]
    for i in range(1,len(L)):
        if last < (1-delta)*L[i]:
            last = L[i]
            Ls.append(last)
    return set(Ls)
                </code></pre>
                <a href="https://pythontutor.com/visualize.html#code=def%20ListTrim%28S,delta%29%3A%0A%20%20%20%20L%20%3D%20sorted%28S%29%0A%20%20%20%20last%20%3D%20L%5B0%5D%0A%20%20%20%20Ls%20%3D%20%5BL%5B0%5D%5D%0A%20%20%20%20for%20i%20in%20range%281,len%28L%29%29%3A%0A%20%20%20%20%20%20%20%20if%20last%20%3C%20%281-delta%29*L%5Bi%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20last%20%3D%20L%5Bi%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20Ls.append%28last%29%0A%20%20%20%20return%20set%28Ls%29%0A%0AS%20%3D%20%7B10,11,12,15,20,21,22,23,24,29%7D%0Adelta%20%3D%200.1%20%0Aprint%28S%29%0AS%20%3D%20ListTrim%28S,%20delta%29%0Aprint%28S%29&cumulative=false&curInstr=41&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false"
                   target="_blank">Визуалиазация</a>
            </section>
            <section>
                <pre><code data-trim data-noescape data-line-numbers class="python">
def ApproxSubSetSum(S,t,delta):
    sums = {0};
    for element in S:
        new_sums = [(s+element) for s in sums if s+element <= t]
            #Удаляем из sums элементы больше t
        sums.update(new_sums)
        sums = ListTrim(sums, delta)
    return max(sums)
        #возвращаем максимальный элемент из sums
                </code></pre>
            </section>
            <section>
                <h4>Задача о суммах подмножеств</h4>
                <h4>Теорема</h4>
                <p>Алгоритм ApproxSubSetSum является полностью полиномиальной схемой приближения для задачи о суммах
                    подмножеств.</p>
                <p>Число элементов в списке в любой момент времени не превосходит</p>
                \[\frac{n \log t}{\delta}+2\]
            </section>
        </section>
        <section>
            <h1>Спасибо за внимание!</h1>
        </section>
    </div>
</div>
<script src="../dist/reveal.js"></script>
<script src="../plugin/notes/notes.js"></script>
<script src="../plugin/markdown/markdown.js"></script>
<script src="../plugin/highlight/highlight.js"></script>
<script src="../plugin/math/math.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.addEventListener('ready', function (event) {
        document.dispatchEvent(new Event('reveal-ready'));
    });
    Reveal.initialize({
        hash: true,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.MathJax2]
    });

</script>
</body>
</html>